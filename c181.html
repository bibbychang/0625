<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>åœ°åœ–ç·¨è¼¯ + å¤§å¯Œç¿éŠæˆ²</title>
  <script src="https://mlc.ai/web-llm/dist/bundle.js">
  
  // æ–°ç‰ˆé€£é–äº‹ä»¶è™•ç†ï¼ˆå¾ªç’°æ–¹å¼ï¼‰
  async function handleEventChain(playerIdx, diceCount = null) {
    // é¦–æ¬¡è¨˜éŒ„æ“²éª°å‹•ä½œ
    if (diceCount !== null) {
      const pos = playerSteps[playerIdx];
      logAction(playerIdx, diceCount, pathIndices[pos]);
    }
    // äº‹ä»¶é€£é–å¾ªç’°
    while (true) {
      const step = playerSteps[playerIdx];
      const cellIdx = pathIndices[step];
      const img = mapData[cellIdx] || '';
      if (img.includes('event1.png') || img.includes('event2.png')) {
        const event = eventList[Math.floor(Math.random() * eventList.length)];
        alert(`ğŸ² äº‹ä»¶å¡ï¼š\n${event.desc}\nâ¡ æ•ˆæœï¼š${event.effect}`);
        logEvent(playerIdx, event.desc);
        let newStep = step;
        switch (event.effect) {
          case 'å‰é€²1æ ¼': newStep = (step + 1) % pathIndices.length; break;
          case 'å‰é€²2æ ¼': newStep = (step + 2) % pathIndices.length; break;
          case 'é€€å›1æ ¼': newStep = (step - 1 + pathIndices.length) % pathIndices.length; break;
          case 'é€€2æ ¼':    newStep = (step - 2 + pathIndices.length) % pathIndices.length; break;
          case 'å›åˆ°èµ·é»': newStep = 0; break;
          case 'å¾—2åˆ†':
            if (mode === 'score') { playerScores[playerIdx] += 2; updateStatus(); }
            break;
          case 'åœä¸€å›åˆ':
            skipTurn[playerIdx] = true;
            break;
        }
        await animateMoveAsync(playerIdx, pathIndices[step], pathIndices[newStep]);
        playerSteps[playerIdx] = newStep;
        continue;
      }
      break;
    }
    // Quiz è™•ç†
    const step = playerSteps[playerIdx];
    const cellIdx = pathIndices[step];
    const img = mapData[cellIdx] || '';
    if (img.includes('quiz.png')) {
      askQuiz(playerIdx, () => nextPlayer(), () => nextPlayer());
      return;
    }
    // underdesk è™•ç†
    if (img.includes('underdesk.png')) {
      alert('ğŸ“¢ ä½ èº²åˆ°æ›¸æ«ƒä¸‹ï¼Œè¢«æ›¸å£“å€’ï¼é€€å›èµ·é»');
      await animateMoveAsync(playerIdx, pathIndices[step], pathIndices[0]);
      playerSteps[playerIdx] = 0;
      return nextPlayer();
    }
    // ä¸€èˆ¬æ ¼ï¼Œæ›ä¸‹ä¸€ä½ç©å®¶
    nextPlayer();
  }

  // Promise åŒ– animateMove
  function animateMoveAsync(playerIdx, fromIdx, toIdx) {
    return new Promise(resolve => {
      animateMove(playerIdx, fromIdx, toIdx, resolve);
    });
  }

  // é‡å¯« rollDice
  function rollDice() {
    if (gameEnded) return;
    if (skipTurn[currentPlayer]) {
      alert(`ğŸ›‘ ç©å®¶ ${currentPlayer + 1} åœä¸€å›åˆ`);
      skipTurn[currentPlayer] = false;
      return nextPlayer();
    }
    const dice = Math.floor(Math.random() * 6) + 1;
    alert(`ç©å®¶${currentPlayer + 1} æ“²å‡º ${dice}`);
    const prev = playerSteps[currentPlayer];
    const next = (prev + dice) % pathIndices.length;
    playerSteps[currentPlayer] = next;
    animateMoveAsync(currentPlayer, pathIndices[prev], pathIndices[next])
      .then(() => handleEventChain(currentPlayer, dice));
  }

  // æ›äºº
  function nextPlayer() {
    currentPlayer = (currentPlayer + 1) % 2;
    document.getElementById('currentPlayer').textContent = currentPlayer + 1;
  }

  // ç´€éŒ„äº‹ä»¶æ—¥èªŒ
  function logEvent(playerIdx, desc) {
    const log = document.getElementById('log');
    log.innerText += `\nç©å®¶${playerIdx+1} è§¸ç™¼äº‹ä»¶ï¼šã€Œ${desc}ã€\n`;
    log.scrollTop = log.scrollHeight;
  }

  // ç´€éŒ„ç§»å‹•æ—¥èªŒ
  function logAction(playerIdx, dice, pos) {
    const log = document.getElementById('log');
    const stepNum = pathIndices.indexOf(pos) + 1;
    const name = (mapData[pos] || '').split('/').pop();
    log.innerText += `ç©å®¶${playerIdx+1} æ“²å‡º ${dice}ï¼Œç§»å‹•åˆ°ç¬¬${stepNum}æ ¼ï¼ˆ${name}ï¼‰\n`;
    log.scrollTop = log.scrollHeight;
  }
</script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #main {
      display: flex;
      flex: 1;
    }
    #editor, #game {
      flex: 1;
      overflow: auto;
      padding: 10px;
    }
    #editor {
      border-right: 2px solid #ccc;
    }
    #sidebar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 10px;
    }
    #sidebar img {
      width: 60px;
      height: 60px;
      cursor: grab;
      border: 1px solid #aaa;
      background: white;
      border-radius: 6px;
    }
    #map {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 2px;
      background-color: #fff;
    }
    .cell {
      width: 60px;
      height: 60px;
      background: #fff;
      border: 1px solid #aaa;
      position: relative;
      overflow: hidden;
    }
    .cell img {
      width: 60px;
      height: 60px;
      position: absolute;
      top: 0;
      left: 0;
      object-fit: contain;
    }
    .cell .order-number {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 10px;
      color: black;
      background: rgba(255,255,255,0.7);
      padding: 1px 3px;
      border-radius: 4px;
      z-index: 3;
    }
    .start-cell {
      border: 2px solid green !important;
    }
    .goal-cell {
      border: 2px solid gold !important;
    }
    #game-board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      gap: 2px;
    }
    .player {
      width: 40px;
      height: 40px;
      position: absolute;
      z-index: 5;
      transition: transform 0.4s ease;
    }
    .player1 {
      top: 4px;
      left: 4px;
    }
    .player2 {
      top: 4px;
      right: 4px;
    }
    .player img {
      width: 100%;
      height: 100%;
    }
	#log {
      margin-top: 10px;
      font-size: 14px;
      white-space: pre-line;
      background: #f9f9f9;
      padding: 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      max-height: 200px;
      overflow-y: auto;
    }
	@keyframes slideIn {
  from { transform: translateY(-30px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}
  </style>
</head>
<body>
  <h1>å¤§å¯Œç¿åœ°åœ–ç·¨è¼¯å™¨ + éŠæˆ²</h1>
  <div id="main">
    <div id="editor">
		<div>
       <label><input type="radio" name="mode" value="time" checked onchange="updateMode()"> é™æ™‚åˆ¶</label>
      <select id="timeLimit">
        <option value="20">20 ç§’</option>
        <option value="50">50 ç§’</option>
        <option value="120">2 åˆ†é˜</option>
      </select>
      <label style="margin-left: 10px"><input type="radio" name="mode" value="score" onchange="updateMode()"> ç©åˆ†åˆ¶</label>
      <select id="scoreTarget" disabled>
        <option value="25">25 åˆ†</option>
        <option value="35">35 åˆ†</option>
        <option value="45">45 åˆ†</option>
      </select>
      </div>
      <h3>æ‹–æ›³åœ–ç‰‡é€²æ ¼å­</h3>
      <div id="sidebar">
        <img src="start.png" class="item" draggable="true" data-img="start.png">
        <img src="goal.png" class="item" draggable="true" data-img="goal.png">
        <img src="bag1.png" class="item" draggable="true" data-img="bag1.png">
		<img src="bag2.png" class="item" draggable="true" data-img="bag2.png">
		
		<img src="card1.png" class="item" draggable="true" data-img="card1.png">
		<img src="card2.png" class="item" draggable="true" data-img="card2.png">
		<img src="dice.png" class="item" draggable="true" data-img="dice.png">
		<img src="earthquake1.png" class="item" draggable="true" data-img="earthquake1.png">
        <img src="earthquake2.png" class="item" draggable="true" data-img="earthquake2.png">
		<img src="earthquake3.png" class="item" draggable="true" data-img="earthquake3.png">
    <img src="event1.png" class="item" draggable="true" data-img="event1.png">
    <img src="event2.png" class="item" draggable="true" data-img="event2.png">
    <img src="fire1.png" class="item" draggable="true" data-img="fire1.png">
    <img src="fire2.png" class="item" draggable="true" data-img="fire2.png">
	<img src="firetruck.png" class="item" draggable="true" data-img="firetruck.png">
    <img src="firstaid2.png" class="item" draggable="true" data-img="firstaid2.png">
	<img src="light.png" class="item" draggable="true" data-img="light.png">
	<img src="ok1.png" class="item" draggable="true" data-img="ok1.png">
	<img src="ok2.png" class="item" draggable="true" data-img="ok2.png">
	<img src="ok3.png" class="item" draggable="true" data-img="ok3.png">
    <img src="quiz.png" class="item" draggable="true" data-img="quiz.png">
    
	<img src="rain1.png" class="item" draggable="true" data-img="rain1.png">
	<img src="rain2.png" class="item" draggable="true" data-img="rain2.png">
	<img src="rain3.png" class="item" draggable="true" data-img="rain3.png">
	<img src="safe.png" class="item" draggable="true" data-img="safe.png">
	<img src="safezone.png" class="item" draggable="true" data-img="safezone.png">
	<img src="warning1.png" class="item" draggable="true" data-img="warning1.png">
    <img src="warning2.png" class="item" draggable="true" data-img="warning2.png">
	<img src="underdesk.png" class="item" draggable="true" data-img="underdesk.png">
	
      </div>
	  <button onclick="loadMap1()">ğŸ“Œ åœ°åœ–1</button><button onclick="startGame()">â–¶ é–‹å§‹éŠæˆ²</button>
      <div id="map"></div>
      
    </div>
    <div id="game">
      <h3>éŠæˆ²å€</h3>
      <div id="game-board"></div>
      <p>
        <button onclick="rollDice()">ğŸ² ç©å®¶ <span id="currentPlayer">1</span> æ“²éª°</button>
        <span id="people">-</span>  æ“²å‡º <span id="diceResult">-</span>
      </p>
      <p id="status"></p>
	  <div id="log"></div>
    </div>
  </div>
  <script>
  let timer = null;
let timeLeft = 0;
  let quizQuestions = [];

fetch("quiz.json")
  .then(res => res.json())
  .then(data => quizQuestions = data);
  const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];
  
  let skipTurn = [false, false];
const eventList = [
  { desc: "E01ï¼šåœ°éœ‡ç™¼ç”Ÿæ™‚ï¼Œä½ ç«‹åˆ»èº²åˆ°å …å›ºæ¡Œå­ä¸‹ã€‚å¹¸é‹é€ƒéä¸€åŠ«ï¼", effect: "å‰é€²1æ ¼" },
  { desc: "E02ï¼šåœ°éœ‡æ™‚ä½ è·‘å‘æ¨“æ¢¯é€ƒç”Ÿï¼Œè¢«è­¦è¡›åˆ¶æ­¢ã€‚åœä¸€å›åˆåæ€ã€‚", effect: "åœä¸€å›åˆ" },
  { desc: "E03ï¼šä½ å¿˜äº†å›ºå®šæ›¸æ«ƒï¼Œåœ°éœ‡æ™‚æ±è¥¿æ‰ä¸‹ä¾†ï¼Œè«‹é€€å›1æ ¼ã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E04ï¼šåœ°éœ‡å¾Œé¦¬ä¸Šé–‹ç“¦æ–¯ç…®æ³¡éºµï¼Œç™¼ç”Ÿç«è­¦ï¼", effect: "å›åˆ°èµ·é»" },
  { desc: "E05ï¼šä½ ç†Ÿè¨˜ç–æ•£è·¯ç·šï¼Œè¿…é€Ÿå¸¶åŒå­¸æ’¤é›¢ï¼Œç²å¾—å¾—2åˆ†ã€‚", effect: "å¾—2åˆ†" },
  { desc: "E06ï¼šä½ ç”¨é˜²ç½åŒ…ä¸­çš„å“¨å­å‘¼æ•‘ï¼ŒæˆåŠŸç²æ•‘ï¼", effect: "å‰é€²2æ ¼" },
  { desc: "E07ï¼šä½ å†·éœèº²é¿ä¸¦å¹«åŠ©åŒå­¸é€ƒé›¢ï¼Œè¡¨ç¾å„ªç§€ï¼", effect: "å‰é€²2æ ¼" },
  { desc: "E08ï¼šåœ°éœ‡å¾Œæ‰“é›»è©±å ±å¹³å®‰ï¼Œé›»è©±æ“å¡ä¸­ã€‚", effect: "åœä¸€å›åˆ" },
  { desc: "E09ï¼šåœ°éœ‡æ™‚çª—æˆ¶ç ´è£‚ä½ è¢«ç¢ç»ç’ƒåŠƒå‚·ã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E10ï¼šä½ åƒåŠ é˜²éœ‡æ¼”ç·´ï¼Œç†Ÿæ‚‰é¿é›£è·¯ç·šï¼", effect: "å¾—2åˆ†" },
  { desc: "E11ï¼šä½ èº²åœ¨æ›¸æ«ƒæ—é‚Šï¼Œè¢«æ›¸å£“å€’ã€‚", effect: "å›åˆ°èµ·é»" },
  { desc: "E12ï¼šåœ°éœ‡æ™‚ä½ å¤§å–Šã€Œä¸è¦å‹•ã€è®“å¤§å®¶é©šæ…Œã€‚", effect: "é€€å›1æ ¼" },
  { desc: "E13ï¼šä½ èº²åœ¨å»æ‰€è£¡ï¼Œè¢«å¡ä½äº†ï¼", effect: "åœä¸€å›åˆ" },
  { desc: "E14ï¼šä½ è·Ÿæœ‹å‹é–‹ç©ç¬‘èªªã€Œåœ°éœ‡å¿«ä¾†ã€ï¼ŒçµæœçœŸçš„æ–äº†ï¼", effect: "é€€å›1æ ¼" },
  { desc: "E15ï¼šåœ°éœ‡æ™‚ï¼Œä½ æ‹å½±ç‰‡ä¸Šå‚³ï¼Œåè€Œçµ†å€’è¢«å›°ä½ã€‚", effect: "å›åˆ°èµ·é»" },
  { desc: "E16ï¼šä½ å¹«è€å¸«æ¬é˜²ç½ç‰©è³‡ï¼Œæœ‰å‚™ç„¡æ‚£ã€‚", effect: "å‰é€²2æ ¼" },
  { desc: "E17ï¼šåœ°éœ‡åŒ…è£¡æœ‰æ°´å’Œå“¨å­ï¼Œä½ å†·éœç­‰å¾…æ•‘æ´ï¼", effect: "å‰é€²1æ ¼" },
  { desc: "E18ï¼šä½ è½å¾å»£æ’­æŒ‡ç¤ºå‰å¾€ç©ºåœ°é¿é›£ã€‚", effect: "å¾—2åˆ†" }
];

  
  
  const mapEl = document.getElementById("map");
    const gameBoard = document.getElementById("game-board");
    let mapData = [], pathIndices = [], placedOrder = [];
    let playerSteps = [0, 0];
    let currentPlayer = 0;
    let gameEnded = false;
    let playerTokens = [null, null];
    let mode = "time";
    let roundGoal = 1;
    //let playerRounds = [0, 0];
    let playerScores = [0, 0];
    let scoreGoal = 25;

  for (let i = 0; i < 64; i++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.cell = i;
      cell.ondragover = e => e.preventDefault();
      cell.ondrop = drop;
      mapEl.appendChild(cell);
    }

    document.querySelectorAll('.item').forEach(item => {
      item.ondragstart = e => {
        e.dataTransfer.setData('text/plain', item.dataset.img);
      };
    });
function askQuiz(playerIndex,onCorrect, onWrong) {
  const synth = window.speechSynthesis;
  const quiz = quizQuestions[Math.floor(Math.random() * quizQuestions.length)];

  const modal = document.createElement("div");
  modal.style.position = "fixed";
  modal.style.top = "0";
  modal.style.left = "0";
  modal.style.width = "100%";
  modal.style.height = "100%";
  modal.style.backgroundColor = "rgba(0,0,0,0.7)";
  modal.style.display = "flex";
  modal.style.justifyContent = "center";
  modal.style.alignItems = "center";
  modal.style.zIndex = "9999";

  const box = document.createElement("div");
  box.style.background = "white";
  box.style.padding = "20px";
  box.style.borderRadius = "8px";
  box.style.width = "300px";
  box.style.boxShadow = "0 4px 10px rgba(0,0,0,0.3)";
  box.style.textAlign = "center";
  box.style.animation = "slideIn 0.4s ease-out";

  const q = document.createElement("h3");
  q.textContent = quiz.question;
  box.appendChild(q);

  quiz.options.forEach(opt => {
    const btn = document.createElement("button");
    btn.textContent = opt;
    btn.style.display = "block";
    btn.style.margin = "8px auto";
    btn.style.padding = "8px 16px";
    btn.style.fontSize = "16px";
    btn.style.cursor = "pointer";
    btn.onclick = () => {
      document.body.removeChild(modal);
      if (opt.trim().startsWith(quiz.answer)) {
        alert("ç­”å°äº†ï¼åŠ 3åˆ†ã€‚");
        playerScores[playerIndex] += 3;   // âœ… ç­”å°åŠ  3 åˆ†
		updateStatus();
      } else {
        alert("ç­”éŒ¯äº†ï¼è¼ªåˆ°ä¸‹ä¸€ä½ç©å®¶ã€‚ä½†ä»æœƒå‰é€²ã€‚");
        logQuizFail(playerIndex, quiz.question);       
      }
    };
    onCorrect();
	box.appendChild(btn);
  });

  modal.appendChild(box);

  // ä½¿ç”¨èªéŸ³æœ—è®€å•é¡Œèˆ‡é¸é …
  const utterance = new SpeechSynthesisUtterance(`${quiz.question} é¸é …æ˜¯ï¼š${quiz.options.join('ã€')}`);
  utterance.lang = 'zh-TW';
  synth.speak(utterance);

  document.body.appendChild(modal);
}


  function drop(e) {
    e.preventDefault();
      const filename = e.dataTransfer.getData('text/plain');
      const cell = e.target.closest('.cell');
      const index = parseInt(cell.dataset.cell);
      cell.innerHTML = '';
      const img = new Image();
      img.src = filename;
      img.width = img.height = 60;
      cell.appendChild(img);
      if (!placedOrder.includes(index)) placedOrder.push(index);
  }
function updateMode() {
      const timeSel = document.getElementById("timeLimit");
  const scoreSel = document.getElementById("scoreTarget");
  mode = document.querySelector('input[name="mode"]:checked').value;
  timeSel.disabled = mode !== "time";
  scoreSel.disabled = mode !== "score";
    }
  function loadMap1() {
    const map1 = [
      { index: 0, img: 'start.png' },
      { index: 1, img: 'event1.png' },
      { index: 2, img: 'event1.png' },
      { index: 3, img: 'event1.png' },
      { index: 4, img: 'quiz.png' },
      { index: 5, img: 'quiz.png' },
      { index: 6, img: 'event2.png' },
      { index: 7, img: 'quiz.png' },
      { index: 15, img: 'quiz.png' },
	  { index: 23, img: 'underdesk.png' },
      { index: 31, img: 'underdesk.png' },
      { index: 30, img: 'event2.png' },
      { index: 29, img: 'quiz.png' },
      { index: 28, img: 'warning2.png' },
	  { index: 27, img: 'underdesk.png' },
      { index: 26, img: 'event2.png' },
      { index: 25, img: 'event2.png' },
      { index: 24, img: 'underdesk.png' },
	  { index: 16, img: 'event2.png' },
      { index: 8, img: 'underdesk.png' },
    ];
    placedOrder = [];
    map1.forEach(({ index, img }) => {
      const cell = mapEl.querySelector(`.cell[data-cell="${index}"]`);
      cell.innerHTML = '';
      const image = new Image();
      image.src = img;
      image.width = image.height = 60;
      cell.appendChild(image);
      placedOrder.push(index);
    });
  }

  function startGame() {
  // é‡è¨­éŠæˆ²ç‹€æ…‹
  playerSteps = [0, 0];
  playerScores = [0, 0];
  currentPlayer = 0;
  gameEnded = false;
  updateStatus();
	gameBoard.innerHTML = '';
      mapData = [];
      pathIndices = [...placedOrder];
      const cells = mapEl.querySelectorAll('.cell');
      cells.forEach((cell, index) => {
        const img = cell.querySelector('img');
        mapData.push(img ? img.src : null);
      });
	  
	   buildGame(); 
  // æ¸…é™¤èˆŠçš„è¨ˆæ™‚å™¨
  clearInterval(timer);

  // æ¨¡å¼åˆ‡æ›è™•ç†
  if (mode === "score") {
    // ç§¯åˆ†åˆ¶ï¼šè¨­å®šç›®æ¨™åˆ†æ•¸
    scoreGoal = parseInt(document.getElementById("scoreTarget").value);
  } else if (mode === "time") {
    // é™æ™‚åˆ¶ï¼šå•Ÿå‹•å€’æ•¸è¨ˆæ™‚
    timeLeft = parseInt(document.getElementById("timeLimit").value);
    const status = document.getElementById("status");
    status.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ ç©å®¶a1: ${playerScores[0]}åˆ† / ç©å®¶2: ${playerScores[1]}åˆ†`;

    timer = setInterval(() => {
      timeLeft--;
      status.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’ ç©å®¶b1: ${playerScores[0]}åˆ† / ç©å®¶2: ${playerScores[1]}åˆ†`;

      if (timeLeft <= 0) {
        clearInterval(timer);
        gameEnded = true;

        // æ¯”è¼ƒé›™æ–¹åˆ†æ•¸
        if (playerScores[0] > playerScores[1]) {
          alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ‰ ç©å®¶ 1 ä»¥ ${playerScores[0]} åˆ†ç²å‹`);
        } else if (playerScores[1] > playerScores[0]) {
          alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ‰ ç©å®¶ 2 ä»¥ ${playerScores[1]} åˆ†ç²å‹`);
        } else {
          alert(`âŒ› æ™‚é–“åˆ°ï¼ğŸ¤ é›™æ–¹å¹³æ‰‹ï¼Œå„å¾— ${playerScores[0]} åˆ†ï¼`);
        }
      }
    }, 1000);
  }
}
  
  function updateStatus() {
  const status = document.getElementById("status");
  if (mode === "time") {
	status.textContent = `é™æ™‚åˆ¶ï¼šå€’æ•¸ ${timeLeft} ç§’  ç©å®¶c1: ${playerScores[0]}åˆ† / ç©å®¶2: ${playerScores[1]}åˆ†`;
  } else {
    status.textContent = `ç©å®¶d1: ${playerScores[0]}åˆ† / ç©å®¶2: ${playerScores[1]}åˆ†`;
  }
}

  function buildGame() {
    for (let i = 0; i < 64; i++) {
      const cell = document.createElement("div");
      cell.className = "cell";
      if (mapData[i]) {
        const img = new Image();
        img.src = mapData[i];
        cell.appendChild(img);
      }
      if (pathIndices.includes(i)) {
        const orderNum = pathIndices.indexOf(i) + 1;
        const label = document.createElement("div");
        label.className = "order-number";
        label.textContent = orderNum;
        cell.appendChild(label);
      }
      if (mapData[i]?.includes("start.png")) cell.classList.add("start-cell");
      if (mapData[i]?.includes("goal.png")) cell.classList.add("goal-cell");
      gameBoard.appendChild(cell);
    }
    renderPlayers(true);
  }

 

  function animateMove(playerIdx, from, to, callback) {
  const token = playerTokens[playerIdx];
      if (!token) return;
      const rectFrom = gameBoard.children[from].getBoundingClientRect();
      const rectTo = gameBoard.children[to].getBoundingClientRect();
      const clone = token.cloneNode(true);
      clone.style.position = 'fixed';
      clone.style.zIndex = '9999';
      clone.style.left = `${rectFrom.left}px`;
      clone.style.top = `${rectFrom.top}px`;
      clone.style.transition = 'all 0.4s ease';
      document.body.appendChild(clone);
      setTimeout(() => {
        clone.style.left = `${rectTo.left}px`;
        clone.style.top = `${rectTo.top}px`;
      }, 10);
      setTimeout(() => {
        document.body.removeChild(clone);
        gameBoard.children[to].appendChild(token);
        if (callback) callback();
      }, 450);
    }

  function renderPlayers(initial = false) {
    document.querySelectorAll(".player").forEach(p => p.remove());
      playerSteps.forEach((step, index) => {
        const cellIndex = pathIndices[step];
        const cell = gameBoard.children[cellIndex];
        if (!cell) return;
        const token = document.createElement("div");
        token.className = `player player${index + 1}`;
        const car = new Image();
        car.src = index === 0 ? "car_red.png" : "car_blue.png";
        token.appendChild(car);
        cell.appendChild(token);
        playerTokens[index] = token;
      });
    }
	function logAction(player, dice, pos) {
      const log = document.getElementById("log");
      const stepNum = pathIndices.indexOf(pos) + 1;
      const imgSrc = mapData[pos] || "";
      const imgName = imgSrc.split('/').pop();
      log.innerText += `ç©å®¶${player + 1} æ“²å‡º ${dice}ï¼Œç§»å‹•åˆ°ç¬¬ ${stepNum} æ ¼ï¼ˆ${imgName}ï¼‰`;
      log.scrollTop = log.scrollHeight;
    }

    function logQuizFail(player, question) {
      const log = document.getElementById("log");
      log.innerText += `ç©å®¶${player + 1} ç­”éŒ¯é¡Œç›®ï¼šã€Œ${question}ã€ï¼Œå¤±å»å‰é€²æ©Ÿæœƒ`;
      log.scrollTop = log.scrollHeight;
    }
	
	function handleEventEffect(event, fromStep,allowEvent = true) {
  alert(`ğŸ² äº‹ä»¶å¡ï¼š\n${event.desc}\nâ¡ æ•ˆæœï¼š${event.effect}`);

  const log = document.getElementById("log");
  log.innerText += `\nè§¸ç™¼äº‹ä»¶ï¼šã€Œ${event.desc}ã€\n`;
  log.scrollTop = log.scrollHeight;

  let newStep = playerSteps[currentPlayer];

  if (event.effect === "å‰é€²1æ ¼") {
    newStep = (newStep + 1) % pathIndices.length;
  } else if (event.effect === "å‰é€²2æ ¼") {
    newStep = (newStep + 2) % pathIndices.length;
  } else if (event.effect === "é€€å›1æ ¼") {
    newStep = (newStep - 1 + pathIndices.length) % pathIndices.length;
  } else if (event.effect === "é€€2æ ¼") {
    newStep = (newStep - 2 + pathIndices.length) % pathIndices.length;
  } else if (event.effect === "å›åˆ°èµ·é»") {
    newStep = 0;
  } else if (event.effect === "å¾—2åˆ†" && mode === "score") {
    playerScores[currentPlayer] += 2;
    updateStatus();
  } else if (event.effect === "åœä¸€å›åˆ") {
    skipTurn[currentPlayer] = true;
  }

  const fromIndex = pathIndices[fromStep];
  const toIndex = pathIndices[newStep];
  playerSteps[currentPlayer] = newStep;

  animateMove(currentPlayer, fromIndex, toIndex, () => {
    updateStatus();

    const img = mapData[toIndex] || "";

    if (img.includes("underdesk.png")) {
      alert("ğŸ“¢ ä½ èµ°åˆ°äº† underdeskï¼è¢«æ›¸å£“å€’ï¼Œé€€å›èµ·é»ï¼");
      const toStart = pathIndices[0];
      const underdeskFrom = toIndex;
      playerSteps[currentPlayer] = 0;
      animateMove(currentPlayer, underdeskFrom, toStart, () => {
        updateStatus();
        // ğŸ¯ æ›ä¸‹ä¸€ä½
        currentPlayer = (currentPlayer + 1) % 2;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      });
    }

    else if (img.includes("quiz.png")) {
      askQuiz(currentPlayer, () => {
        currentPlayer = (currentPlayer + 1) % 2;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      }, () => {
        currentPlayer = (currentPlayer + 1) % 2;
        document.getElementById("currentPlayer").textContent = currentPlayer + 1;
      });
    }

    else if (img.includes("event1.png") || img.includes("event2.png")) {
      // âœ… éè¿´è™•ç†æ–°çš„äº‹ä»¶å¡ï¼Œä½†è¦ç¨å¾®å»¶é²ä»¥ä¿è­‰å‹•ç•«åŸ·è¡Œå®Œç•¢
      setTimeout(() => {
  triggerByStep(newStep, allowEvent);  // ğŸ‘‡ ç”¨ä¸‹é¢æ–°å¢çš„å°è£å‡½æ•¸ä¾†åšåˆ¤æ–·
}, 100); // ç­‰å‹•ç•«å®Œæˆå†è§¸ç™¼ä¸‹ä¸€å€‹äº‹ä»¶
    }

    else {
      // æ²’æœ‰ç‰¹æ®Šæ ¼å­ï¼Œå°±æ›äºº
      currentPlayer = (currentPlayer + 1) % 2;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    }
  });
}
	function triggerByStep(step, allowEvent = true) {
  const cellIndex = pathIndices[step];
  const img = mapData[cellIndex] || "";

  if (img.includes("underdesk.png")) {
    alert("ğŸ“¢ ä½ èµ°åˆ°äº† underdeskï¼è¢«æ›¸å£“å€’ï¼Œé€€å›èµ·é»ï¼");
    const toStart = pathIndices[0];
    playerSteps[currentPlayer] = 0;
    animateMove(currentPlayer, cellIndex, toStart, () => {
      updateStatus();
      currentPlayer = (currentPlayer + 1) % 2;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    });
  }

  else if (img.includes("quiz.png")) {
    askQuiz(currentPlayer, () => {
      currentPlayer = (currentPlayer + 1) % 2;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    }, () => {
      currentPlayer = (currentPlayer + 1) % 2;
      document.getElementById("currentPlayer").textContent = currentPlayer + 1;
    });
  }

  else if ((img.includes("event1.png") || img.includes("event2.png")) && allowEvent) {
    const nextEvent = eventList[Math.floor(Math.random() * eventList.length)];
    handleEventEffect(nextEvent, step,false);
  }

  else {
    currentPlayer = (currentPlayer + 1) % 2;
    document.getElementById("currentPlayer").textContent = currentPlayer + 1;
  }
}
	

  


</script>
    
</body>
</html>
